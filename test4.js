/**
당신은 웹에서 그림을 그릴 수 있는 서비스를 개발 중입니다. 
사용자가 그림을 그릴 수 있는 공간은 크기가 n x m 인 격자로 표현합니다. 
초기 격자의 각 칸은 아무 색이 없는 상태이며, 사용자의 행동에 따라 k 가지 색 중 하나로 칠해 질 수 있습니다. 색은1~ k 사이의 정수로 표현합니다.
사용자는 다음 두 가지 행동을 할 수 있습니다.
1. 행을 칠하는 행동입니다.두 정수 x, p 를고릅니다.그후, x 행의모든 칸을 p 색으로 칠합니다. 
2. 열을 칠하는 행동입니다.두 정수 x, p 를고릅니다.그후, x 열의 모든 칸을 p 색으로 칠합니다.

다음은 n =3, m =4, k = 3이고, 사용자의 행동이 아래 표와 같을 때, 격자에 색이 칠해지는 과정을 나타낸 예시입니다.
순서  행동  x  p
1 행 칠하기 1 2
2 행 칠하기 2 3
3 열 칠하기 4 2

1. 3 x 4 격자의 초기 상태 (아무 색이 없는 칸은 0으로 표시합니다.)
0000
0000
0000

2. x =1행을 p =2로색칠
2222
0000
0000

3. x=2행을 =3로색칠
2222
3332
0002

4. x=4열을 p=2로색칠
2222 
3332 
8002

모든 행동이 끝난 뒤, 모든 색이 각각 몇 개의 칸에 칠해져 있는지 세어보면 아래 표와 같습니다.

색  칸의 개수
1 0
2 6
3 3

사용자가 행동을 할 때마다 매 번 색칠한 상태를 계산하는 것은 매우 비효율적이기 때문에, 
당신은.모든 행동이 끝난 뒤 모든 색이 각각 몇 개의 칸에 칠해져 있는지 계산하려 합니다. 
그림을 그릴 수 있는 공간의 행의 수를 나타내는 정수 n ,
열의 수를 나타내는 정수 m , 
색의 가짓수를 나타내는 정수 k 와 사용자의 행동에 대한 정보가 순서대로 담긴 2차원 정수 배열 acts 가 주어집니다. 
이때, 모든 행동이 끝난 뒤, 1~ k 의 색이 각각 몇 개의 칸에 칠해져 있는지 정수 배열에`1번 색부터 순서대로 담아 return 하도록 solution 함수를 완성해주세요

입출력 예
테스트 1
입력값 〉
3, 4, 3, [[1, 1, 2], [1, 2, 3], [2, 4, 2]]
기댓값 〉
[0, 6, 3]

테스트 2
입력값 〉
3, 3, 6, [[2, 3, 4], [1, 1, 1], [1, 2, 5], [1, 3, 5], [2, 1, 2], [2, 3, 3]]
기댓값 〉
[1, 3, 3, 0, 2, 0]

테스트 3
입력값 〉
1, 1, 2, [[1, 1, 1], [1, 1, 2]]
기댓값 〉
[0, 1]

입출력 예 설명
입출력예 #2
1. 3 x3격자의 초기 상태
000 
000
000

2. x=3열을 p =4로색칠
004 
004 
004

3. x =1행을 p =1로색칠
111
004
004

4. x =2행을 p =5로 색칠
111
555
004

5. x =3행을 p=5로 색칠
111
555
555

6. x =3열을 p =3로 색칠
213
253
253

모든 행동이 끝난 뒤, 1~k 색이 칠해진 칸의 갯수는

색 칸의 개수
1 1
2 3
3 3
4 0
5 2
6 0

따라서 [1,3,3,0,2,0] 을 return 해야 합니다.

*/
function solution(n, m, k, acts) {
  let rowColored = Array(n).fill(0); // 행별 마지막으로 칠해진 색 저장
  let colColored = Array(m).fill(0); // 열별 마지막으로 칠해진 색 저장
  let colorCount = Array(k + 1).fill(0); // 색깔별 칸 수 저장

  for (let act of acts) {
    let type = act[0], x = act[1] - 1, color = act[2];

    if (type === 1) { // 행 칠하기
      rowColored[x] = color; 
    } else { // 열 칠하기
      colColored[x] = color;
    }
  }

  // 각 칸의 색깔을 확인하고 개수를 셈
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      // 행 또는 열이 마지막으로 칠해진 색깔로 결정
      let finalColor = rowColored[i] ? rowColored[i] : colColored[j]; 
      colorCount[finalColor]++;
    }
  }

  return colorCount.slice(1); 
}

// 테스트 케이스 실행
console.log(solution(3, 4, 3, [[1, 1, 2], [1, 2, 3], [2, 4, 2]]));  // [0, 6, 3]
console.log(solution(3, 3, 6, [[2, 3, 4], [1, 1, 1], [1, 2, 5], [1, 3, 5], [2, 1, 2], [2, 3, 3]]));  // [1, 3, 3, 0, 2, 0]
console.log(solution(1, 1, 2, [[1, 1, 1], [1, 1, 2]]));  // [0, 1]
