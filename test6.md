# 다음중 cors 에러가 발생하는 경우를 모두 고르시오
1. JSONP를 이용한 요청을 할 때
2. 이미지 태그(src 속성)를 이용한 요청을 할 때
3. 같은 도메인이지만 다른 포트로 요청
- CORS 에러가 발생할 수 있습니다. 같은 도메인이지만 다른 포트는 다른 출처로 간주되므로 CORS 정책이 적용됩니다.

4. 헤더에 Access-Control-Allow-Origin 추가
5. 리버스 프록시를 이용해 서버에 요청을 보낼 때

# Saas에서 @import 대신 @use 사용을 관장하는 이유로 알맞지 않은 것을 모두 고르시오

1. 번들 사이즈 감소
2. namespace 를 이용한 모듈화
3. 컴파일 시간 감소
4. 모든 변수 / 믹스인 / 함수를 전역으로 접근 가능
- @use는 이와 반대되는 접근 방식을 제공합니다. @use는 네임스페이스를 사용하여 변수, 믹스인, 함수를 모듈화하고, 전역 네임스페이스를 오염시키지 않습니다.

5. private member 혹은 placeholder selector 정의 가능

# Sass에서 반복문을 사용하고 싶을 때 쓰는 키워드로 알맞은것을 모두 말하시오
@for
@each
@while

# this 키워드 바인딩에 영향을 줄 수 있는 것을 모두 고르시오
1. 함수를 호출한 객체
- 함수가 어떤 객체의 메서드로 호출되었는지에 따라 this가 바인딩됩니다. 예를 들어, 객체의 메서드를 호출하면 this는 그 객체를 가리킵니다.

2. 화살표 함수
- 화살표 함수는 자신만의 this를 가지지 않고, 화살표 함수가 정의된 위치에서의 this를 상속받습니다.

3. 함수의 파라미터
4. 함수의 반환값
5. new 키워듬
- new 키워드를 사용하여 함수를 호출하면, this는 새로 생성된 인스턴스를 가리키게 됩니다.

# Promise의 상태가 아닌 것을 모두 고르시오
1. requested
2. rejected
3. fulfilled 
4. catched
5. pending
- Promise의 상태는 pending, fulfilled, rejected 세 가지입니다.

# typescript에서 특정 필드를 제외시키는 키워드를 고르시오
1. emit
2. pick
3. omit
- Omit 키워드는 타입에서 특정 필드를 제외시킬 때 사용됩니다. 이는 제네릭 타입으로, 첫 번째 인자로 주어진 타입에서 두 번째 인자로 주어진 필드를 제외한 타입을 생성합니다.
4. partial
5. exclude

# typescript에서 객체 T의 모든 value를 가지는 union type을 만드는 코드로 알맞은 것을 고르시오.
1. keyof T
- keyof T: 객체 T의 모든 키를 가지는 유니언 타입을 생성합니다.

2. (typeof T)[keyof typeof T]
- (typeof T)[keyof typeof T]: T가 타입이 아니라 값이라면, 값의 타입을 얻기 위해 typeof를 사용한 코드입니다. 객체 T의 값 타입을 얻으려는 것이 아니므로, 틀린 접근입니다.

3. valueof T
- valueof T: TypeScript에는 valueof 키워드는 존재하지 않습니다. 틀린 접근입니다.

4. T[keyof T]
- T[keyof T]: 객체 T의 모든 값을 가지는 유니언 타입을 생성합니다. 올바른 답변입니다.

5. T[keyof typeof T]
- T[keyof typeof T]: typeof T는 T가 값일 때 사용합니다. 객체 T의 값 타입을 얻으려는 것이 아니므로, 틀린 접근입니다.


# flex layout에서 flexitem이 늘어나는 알고리즘에 대한 설명으로 옳은 것은?
1. 각 flexitem의 너비에 따라 비율대로 남은 공간을 채웁니다.
2. flex-grow에서 flex-shrink를 뺀 값을 기준으로 각 flexitem이 늘어납니다.
3. 모든 flexitem이 전부 동일하게 남은 공간을 나눠가집니다.
4. 남은 공간이 있어도 flexitem이 늘어나지 않습니다.
5. flex-grow 비율에 따라 남은 flexitem이 늘어납니다.
- flex-grow: 남은 공간을 flex item들이 차지할 때 사용됩니다. flex-grow의 값은 상대적인 비율을 나타내며, 각 flex item이 이 값을 기반으로 남은 공간을 나눕니다.
- flex-shrink: flex container의 크기가 줄어들 때 flex item이 얼마나 줄어들지를 결정합니다.
- flex-basis: flex item의 기본 크기를 설정합니다.

# 숫자로만 이루어진 6자리의 비밀번호를 확인하는 정규표현식으로 올바른것을 모두 고르시오
1. \d{6}
- a123456b
2. \d{6}(?!.)
- a123456
3. \d{6,6}
- 1234567
-- 6자리 숫자가 아닌 7자리 숫자의 부분포함
4. ^\d{1,6}$
- 12345
5. [0-9]{6}
- 부분포함
- 문제가 이상했음.


# Vue.js에서 컴포넌트 간 통신을 위해 사용되는 방법은 무엇인가요?
1. props / event
- 당연
2. method / computed
3. filter / mixin
4. watchers / directive

# Vue.js에서 컴포넌트의 라이프사이클 훅 중 befireCreate와 created 훅 사이에서 발생하는 작업은 무엇인가요?
1. 컴포넌트의 템플릿이 렌더링 되기 전에 실행됩니다.,
2. 컴ㅍ넌트의 템플릿이 렌더링된 후에 실행됩니다.
3. 컴포넌트의 데이터와 메서드가 초기화되기 전에 실행됩니다.
4. 컴포넌트의 데이터와 메서드가 초기화된 후에 실행됩니다.
- beforeCreate: 이 훅은 컴포넌트 인스턴스가 초기화될 때 가장 먼저 호출됩니다. 이 시점에는 데이터, 메서드, 컴퓨티드 속성 등이 아직 설정되지 않았습니다.
데이터와 메서드 초기화: beforeCreate 훅이 호출된 후, Vue는 컴포넌트의 data 속성과 methods 속성을 초기화합니다.
created: 이 훅은 데이터와 메서드가 초기화된 후 호출됩니다. 이 시점에서 컴포넌트의 반응형 데이터와 메서드가 설정되어 사용할 준비가 되어 있습니다.
따라서 beforeCreate와 created 사이에 발생하는 작업은 데이터와 메서드의 초기화입니다. 이로 인해 정답은 **4. 컴포넌트의 데이터와 메서드가 초기화된 후에 실행됩니다.**입니다.


# vue에서 컴포넌트 간 통신을 위해 사용되는 provide와 inject에 대한 설명으로 옳은 것은?
1. 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때 사용합니다.
- 틀린 설명입니다. provide와 inject는 깊이 중첩된 자식 컴포넌트로 데이터를 전달할 때 사용되지만, 일반적으로 props를 사용합니다.

2. 자식 컴포넌트에서 부모 컴포넌트의 데이터를 받아와 사용하기 위해 사용합니다.
3. 전역으로 데이터를 공유하기 위해 사용합니다.
- 틀린 설명입니다. provide와 inject는 계층 구조 내에서 데이터를 공유하기 위해 사용됩니다. 전역 상태 관리는 주로 Vuex와 같은 상태 관리 라이브러리를 사용합니다.

4. 컴포넌트 간의 이벤트를 전파하기 위해 사용합니다.
- 틀린 설명입니다. 이벤트 전파는 주로 이벤트 버스(Event Bus) 또는 $emit과 $on을 사용하여 이루어집니다.


provide: 부모 컴포넌트에서 데이터를 제공(provide)하는 메소드입니다. 부모 컴포넌트의 provide 속성에 데이터를 정의하면, 이 데이터를 하위 컴포넌트에서 접근할 수 있게 됩니다.
inject: 자식 컴포넌트에서 부모 컴포넌트가 제공한(provide) 데이터를 주입(inject)받아 사용하는 메소드입니다. 자식 컴포넌트의 inject 속성에 데이터를 정의하면, 부모 컴포넌트가 제공한 데이터를 받아올 수 있습니다.


# vue.js에서 v-if와 v-show에 대해 올바른 설명은?
1. v-if는 css 기반 토글을 통해 초기 조건에 관계없이 항상 렌더링된다.
- 틀린 설명입니다. v-if는 조건이 참일 때만 요소를 DOM에 추가하고, 조건이 거짓이면 요소를 DOM에서 제거합니다. 따라서 초기 조건이 거짓이면 해당 요소는 렌더링되지 않습니다.

2. 런타임 시 조건이 변경될 가능성이 없는 경우에는 v-if를 사용하는 것이 좋다.
- 틀린 설명입니다. v-if는 요소를 동적으로 추가하거나 제거할 때 성능에 더 많은 비용이 들 수 있습니다. 조건이 자주 변경되지 않으면 v-show를 사용하는 것이 좋습니다.

3. v-show는 초기 렌더링 조건이 거짓이면 아무 작업도 수행하지 않는다.
- 틀린 설명입니다. v-show는 초기 렌더링 시 조건이 거짓이더라도 요소를 DOM에 추가하지만, display 속성을 통해 가시성을 제어합니다. 조건이 거짓이면 display: none이 설정됩니다.

4. v-if, v-show 조건 블록은 모두 조건이 처음으로 참이 될때까지 렌더링 되지 않는다
- 틀렸습니다. v-if는 조건이 처음으로 참이 될 때까지 요소를 렌더링하지 않지만, v-show는 조건과 상관없이 처음부터 요소를 렌더링하고 단지 표시 여부를 토글합니다.

# nuxt.js에서 미들웨어의 역할을 모두 고르시오
1. 클라이언트와 서버 간의 데이터통신을 관리합니다.
- 틀렸습니다. 미들웨어는 클라이언트와 서버 간의 직접적인 데이터 통신을 관리하지 않습니다. 이는 API 호출이나 서버 통신 로직에서 다루어집니다.

2. 페이지 로딩 전에 실행되는 로직을 처리합니다.
- 맞습니다. 미들웨어는 페이지가 로드되기 전에 특정 작업을 수행할 수 있도록 합니다. 예를 들어, 사용자 인증 검사, 리다이렉션, 데이터 가져오기 등이 가능합니다.

3. 데이터 상태를 관리하고 조작합니다.
- 맞습니다. 미들웨어는 상태 관리 라이브러리와 결합하여 상태를 조작하거나 초기화할 수 있습니다. 예를 들어, Vuex 스토어의 상태를 변경하는 작업을 미들웨어에서 수행할 수 있습니다.

4. 라우팅을 처리하고 페이지 간의 전환을 관리합니다.
- 맞습니다. 미들웨어는 라우팅 과정에서 특정 조건을 검사하고, 필요한 경우 리다이렉션을 통해 페이지 전환을 관리할 수 있습니다.
따라서, Nuxt.js에서 미들웨어가 할 수 있는 역할은 다음과 같습니다:

2. 페이지 로딩 전에 실행되는 로직을 처리합니다.
3. 데이터 상태를 관리하고 조작합니다.
4. 라우팅을 처리하고 페이지 간의 전환을 관리합니다.

# nuxt에서 동적 라우트를 구현하기 위해 사용되는 디렉토리 구조는 무엇인가요?
1. views 디렉토리 내의 [slug].vlue 파일로 구현합니다.
2. components 디렉토리 내의 [slug].vue 파일로 구현합니다.
3. layouts 디렉토리 내의 [id].vue 파일로 구현합니다.
4. pages 디렉토리 내의 [id].vue 파일로 구현합니다.
Nuxt.js에서는 pages 디렉토리 내에 파일과 디렉토리 구조를 정의하여 라우트를 설정합니다. 동적 라우트를 만들기 위해서는 대괄호 []를 사용하여 파일 이름을 지정합니다. 예를 들어, pages/[id].vue 파일을 생성하면 /some-id와 같은 동적 경로를 처리할 수 있습니다.

따라서 정답은 **4. pages 디렉토리 내의 [id].vue 파일로 구현합니다.**입니다.



# nuxt.js에서 public 디렉토리의 역할은 무엇인가요?
1. 페이지 컴포넌트의 템플릿 파일을 저장하기 위해 사용합니다.
- 틀렸습니다. 페이지 컴포넌트의 템플릿 파일은 pages 디렉토리에 저장됩니다. Nuxt.js는 pages 디렉토리를 기반으로 라우트를 자동으로 생성합니다.

2. 서버 사이드 렌더링을 위한 스태틱 파일을 저장하기 위해 사용합니다.
- 틀렸습니다. 서버 사이드 렌더링을 위한 스태틱 파일은 주로 static 디렉토리에 저장되거나 public 디렉토리에서 호스팅됩니다. public 디렉토리는 정적 파일을 호스팅하는 데 사용되며, 서버 사이드 렌더링 자체를 위해 특별히 파일을 저장하는 용도로 사용되지는 않습니다.

3. 정적 파일(이미지, css, js 등)을 호스팅하기 위해 사용합니다.
- 맞습니다. public 디렉토리는 정적 파일(이미지, CSS, JavaScript 파일 등)을 호스팅하기 위해 사용됩니다. 이 디렉토리에 저장된 파일들은 빌드 과정에서 그대로 복사되어 / 경로로 접근할 수 있게 됩니다.

4. nuxt.js의 빌드 시스템에 의해 생성되는 파일을 저장하기 위해 사용합니다.
- 틀렸습니다. Nuxt.js의 빌드 시스템에 의해 생성되는 파일은 dist 디렉토리에 저장됩니다. 이 디렉토리는 프로덕션 배포 시 사용됩니다. 빌드 과정에서 생성된 파일들은 이곳에 저장되어 서버에 배포됩니다.


# nuxt.js에서 사용되는 "asyncData", "useAsyncData"의 주요 특징은 무엇인가요?

1. promise를 반환하고 비동기 데이터를 처리하기 위해 사용합니다.
2. 서버 사이드에서 실행되어 페이지 컴포넌트의 데이터를 미리 가져옵니다.
3. 클라이언트 사이드에서 실행되어 페이지 컴포넌트의 데이터를 초기화합니다.
4. vuex 스토어와 연동하여 전역 상태를 관리합니다.

# nuxt.js에서 컴포넌트를 비동기적으로 로드하는 방법은 무엇인가요?
1. <nuxt-link>를 사용하여 컴포넌트를 비동기적으로 로드합니다.
- 틀렸습니다. <nuxt-link>는 Nuxt.js에서 페이지 간의 내비게이션을 위한 컴포넌트입니다. 비동기 컴포넌트 로딩과는 관계가 없습니다.

2. <nuxt-load>를 사용하여 컴포넌트를 비동기적으로 로드합니다.
- 틀렸습니다. <nuxt-load>는 존재하지 않는 컴포넌트입니다. 비동기 로드를 위한 방법이 아닙니다.

3. asyncData() 메소드를 사용하여 컴포넌트를 비동기적으로 로드합니다.
- 틀렸습니다. asyncData() 메소드는 페이지 컴포넌트에서 데이터를 비동기적으로 가져오는 데 사용됩니다. 컴포넌트를 비동기적으로 로드하는 데 사용되지 않습니다.

4. asyncComponent() 메소드를 사용하여 컴포넌트를 비동기적으로 로드합니다.
- Nuxt.js에서는 동적 import 구문을 사용하여 컴포넌트를 비동기적으로 로드할 수 있습니다. Nuxt.js는 Vue.js의 기본 동적 컴포넌트 로딩 방법을 사용하며, 이는 일반적으로 import() 함수와 함께 사용됩니다.



# nuxt.js에서 전역 css 스타일을 추가하는 방법은 무엇인가요?
1. style 디렉토리에 css 파일을 생성하여 자동으로 적용
- 틀렸습니다. style 디렉토리를 생성한다고 해서 CSS 파일이 자동으로 전역 적용되지 않습니다. CSS 파일을 전역적으로 적용하려면 nuxt.config.js 파일의 css 속성에 명시적으로 추가해야 합니다.

2. 컴포넌트에 직접 <style> 태그를 작성하여 스타일 추가
- 틀렸습니다. 이 방법은 특정 컴포넌트에만 스타일을 적용합니다. 전역 스타일을 추가하는 방법이 아닙니다.

3. nuxt.config.js 에서 css 속성을 사용하여 전역 css 파일 지정
- Nuxt.js는 nuxt.config.js 파일에서 css 속성을 사용하여 전역 CSS 파일을 지정할 수 있습니다. 이렇게 하면 지정된 CSS 파일들이 전역적으로 적용됩니다.


4. nuxt.js에서는 전역 css 스타일을 지원하지 않음
- 틀렸습니다. Nuxt.js는 전역 CSS 스타일을 지원합니다. nuxt.config.js 파일을 통해 쉽게 설정할 수 있습니다.
