/**
사이버 코딩 대학(Cyber Coding University, 이하 CCU)은 n개의 반으로 이루어져 있습니다. 
CCU는 학생들의 코딩 실력을 평가하기 위해 온라인 코딩 테스트를 준비 중입니다. 
그런데 학생들의 수가 너무 많아서, 한 대의 서버로는 테스트를 진행할 수 없습니다. 
고민 끝에, CCU는 n개의 반을 k개의 서버로 분 배시켜 코딩 테스트를 진행하기로 했습니다. 
n개의 반을 k개의 서버로 분배시키는데, 아래와 같은 규칙을 따릅니다.
 1.n개의 반은 1반부터 n반까지, k개의 .서버는 1번 서버부터 k번 서버까지 고유 번호가 부여되어 있습니다.
 ( 단, k<=n) 
 
 2. a 번 서버에 포함된 모든 반은 a-1 번 서버에 포함된 모든 반보다 뒷 반이어야 합니다.(2<=a<-k)
 2-1. 예를 들어, 7개의 반을 2개의 서버로 나눈다면, 1,2,3 반을 1번 서버에, 4,5,6,7 반을 2번 서버로 나누는 것은 가능하지만, 1,3,5반을 1번 서버에, 2,4,6,7반을 2번 서버로 나누는 것은 불가능 합니다. 
 2번 서버에 포함된 4반이 1번 서버에 포함된 5반보다 뒷 반이 아니기 때문입니다. 
 2-2. 즉, 7개의 반을 2개의 서버로 분배하는 방법은 총 6가지 입니다. 
 [1반] / [2~7반] [1~2반] / [3~7반] , [1~3반] / 
 [4~7반] [1~4반] / [5~7반] , [1~5반] /` 
 [6~7반] , [1~6반] / 
 [7반] 
 
 3. 각각의 서버에 분배된 학생 수의 최대 값을 최소로 해야 합니다.
 3-1. 예를 들어, 9개 반의 학생 수가 [30, 29, 35, 25, 20, 30, 20, 45, 48] 이고, 3개의 서버로 나누는 경우를 고려해 보겠습니다. 
 3-2. [30, 29, 35] , [25, 20, 30, 20], [45, 48] 으로 나눈다면, 각각의 서버에 분배된 학생 수는 94, 95, 93 명입니다. 
 즉, 주어진 9개의 반을 3개의 서버로 나눈다면, 각각의 서버에 속한 희 생 수가 최대 95 명 이하가 되도록 만들 수 있습니다
 
 4. 한 반은 여러 서버에 분배되어 흘어지지 않습니다. 즉, 하나의 반은 정확히 한 서버에만 분배됩니다.
각 반의 학생 수를 담은 배열 classes와, 반을 나누어서 수용할 서버 수 k가 매개변수로 주어집니다. 
이때, k개의 서버에 속한 학생 수의 최대값이 최소가 되도록 반을 분배했을 때, 그 최소값을 return 하도록 solution 함수를 완성해주세요.

테스트 1
입력값 〉
[30, 29, 35, 25, 20, 30, 20, 45, 48], 3
기댓값 〉
95

테스트 2
입력값 〉
[100, 1, 50, 77, 4854], 5
기댓값 〉
4854

테스트 3
입력값 〉
[1056, 999, 74], 1
기댓값 〉
2129


입출역 예 2
5개의 반을 5개의 서버로 분산시켜야 하므로, 각각의 서버에 한 반씩 분산시킵니다.
마지막 5번 서버에 들어간 학생 수가 4854명으로 가장 많으므로, 이 값을 return 해주어야 합니다.

입출력 예 3
3개의 반을 1개의 서버로 분산시켜야 하므로, 모든 반이 하나의 서버로 몰립니다.
따라서 1056, 999, 74를 모두 더한 값인 2129를 return 해주어야 합니다.

*/
function canDivide(classes, k, maxStudents) {
  let currentSum = 0;
  let serversUsed = 1;

  for (let students of classes) {
      if (currentSum + students > maxStudents) {
          serversUsed += 1;
          currentSum = students;
          if (serversUsed > k) {
              return false;
          }
      } else {
          currentSum += students;
      }
      
  }
  return true;
}

function solution(classes, k) {
  let low = Math.max(...classes);
  let high = classes.reduce((a, b) => a + b, 0);

  while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (canDivide(classes, k, mid)) {
          high = mid;
      } else {
          low = mid + 1;
      }
  }
  return low;
}

// 테스트 케이스 실행
console.log(solution(
  [30, 29, 35, 25, 20, 30, 20, 45, 48], 3

));  // 95
// console.log(solution([100, 1, 50, 77, 4854], 5));  // 4854
// console.log(solution([1056, 999, 74], 1));  // 2129
